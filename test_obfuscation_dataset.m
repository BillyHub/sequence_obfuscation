% Compare each obfuscation method on dataset sequences
clear all

%% parameters initialization
l = 2;% pattern length
h = 10;% pattern letter maximum distance
sigma = 1/10;% for algorithm2

%% load the dataset sequence for each user
% load the location set
load('topTowerList_Top20.mat');
r = size(topTowerList, 2);
% load the dataset sequences
load('user_wholeSeq_sampling_topTower20_10mins_truncated1000_droppedLessThan.mat');
n = size(user_wholeSeq_sampling_truncated,2);
% translate the original data sequence to natural numbers
keySet = topTowerList;
valueSet = 1:r;
M = containers.Map(keySet, valueSet);
user_sequence = {};
user1_search = true;
valid_user_num = 0;% count the number of users whose sequence is not empty
for userIndex = 1:n
    seqLen = size(user_wholeSeq_sampling_truncated{1,userIndex},2);
    if (seqLen > 0)
        if (user1_search)% treat the first valid user as user1
            user1_index = userIndex;
            user1_search = false;
            m = size(user_wholeSeq_sampling_truncated{1,userIndex},2);
        end
        for seq_idx = 1:seqLen
            user_sequence{1,userIndex}(seq_idx) = M(user_wholeSeq_sampling_truncated{1,userIndex}(seq_idx));
        end
        valid_user_num = valid_user_num + 1;
    end
end

%% generate a unique pattern and insert the pattern into user 1's sequence at a random index
if (l == 1)
    user1_pattern = [r+1];
end
if (l == 2)
    user1_pattern = [r+1, r+2];
end
if (l == 3)
    user1_pattern = [r+1, r+2, r+3];
end
place = randi([1,m],1);
user_sequence{1,user1_index} = [user_sequence{1,user1_index}(1:place-1), user1_pattern, user_sequence{1,user1_index}(place:end)];

%% generate the superstring generated by the de bruijn sequence
superstring_seq = de_bruijn_sequence(r+l,l) + 1; % extra l letters for unique pattern; adding one for superstring offset

%% define the validation vector for each obfuscation method
percent_randomObf = [];
%percent_randomObf_theory = [];
percent_deBruijnObf = [];
percent_algorithm1 = [];
%percent_algorithm1_theory = [];
percent_algorithm2 = [];
percent_algorithm3 = [];

%% executing each obfuscation method
for p_obf = 0.02:0.02:0.1
    percent_randomObf = [percent_randomObf, obfuscation_random(user_sequence, user1_pattern, r, n, valid_user_num, p_obf, l, h, 1e3)];
    %percent_randomObf_theory = [percent_randomObf_theory, randomObf_theory_l1(p_obf, r+l, m)];
    percent_deBruijnObf = [percent_deBruijnObf, obfuscation_superstring(user_sequence, superstring_seq, user1_pattern, n, valid_user_num, p_obf, l, h, 1e3)];
    percent_algorithm1 = [percent_algorithm1, algorithm1(user_sequence, user1_pattern, r, n, valid_user_num, p_obf, l, h, 1e2)];
    %percent_algorithm1_theory = [percent_algorithm1_theory, algorithm1_theory_l1(p_obf, r+l, m)];
    percent_algorithm2 = [percent_algorithm2, algorithm2(user_sequence, user1_pattern, r, n, valid_user_num, p_obf, l, h, sigma, 1e2)];
    percent_algorithm3 = [percent_algorithm3, algorithm3(user_sequence, user1_pattern, r, n, valid_user_num, p_obf, l, h, 1e1)];
end

%% plot the figure in terms of p_obf
figure;
p = 0.02:0.02:0.1;
plot(p, percent_randomObf, 'og-');hold on;
%plot(p, percent_randomObf_theory, 'dr-');hold on;
plot(p, percent_deBruijnObf, 'ob-');hold on;
plot(p, percent_algorithm1, 'or-');hold on;
%plot(p, percent_algorithm1_theory, 'dr-');hold on;
plot(p, percent_algorithm2, 'ok-');hold on;
plot(p,percent_algorithm3, 'om-');
xlabel('p_{obf}');ylabel('validation percentage');
legend('random obf', 'de bruijn obf','algorithm1 obf','algorithm2 obf', 'algorithm3 obf', 'Location','southeast');
grid on;
title('r = 20 + l, m = 1000, l = 2, h = 10, using dataset sequence');
